{
  "hash": "b8f5b3a76a9d42a29e36eb56e7e9d02a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Beyond NCBI: the Power of Local BLAST Searches\"\nengine: knitr\nauthor: \"Misha Paauw\"\ndate: 2025-06-20\ncategories: [comparative genomics, BLAST, conda, tutorial]\n---\n\n\n\nThe BLAST algorithm and its interface on [NCBI](https://blast.ncbi.nlm.nih.gov/Blast.cgi) are among the most widely used bioinformatics tools. A typical use case: you discover a DNA or protein sequence of interest, paste it into the BLAST webtool, and voilà: you get a list of similar sequences across the tree of life. Despite its wide taxonomic coverage, the BLAST database at NCBI (`core_nt`) does not include all genomes that were ever assembled. Due to decreasing sequencing costs and the rise of long-read sequencing techniques, it is now feasible to *de novo* assemble high-quality genomes for numerous individuals of the same species. However, not all published genomes (e.g. for tomato: [Along et al.,](https://www.cell.com/cell/fulltext/S0092-8674(20)30616-4) or *Arabidopsis*: [Alonso-Blanco et al.](https://www.biorxiv.org/content/10.1101/2024.12.23.629943v2.abstract) will become available at NCBI BLAST for us to discover. That's where local BLAST searches come in. \n\n## Installing BLAST\n\nFirst, we have to install BLAST. To do this, and to run BLAST commands, we will work on the command line. On macOS you can use the Terminal application. On Windows you need to install [WSL](https://learn.microsoft.com/en-us/windows/wsl/install). The easiest way to install BLAST (and nearly all other bioinformatics tools) is to use `conda`. Follow the instructions [here](https://www.anaconda.com/docs/getting-started/miniconda/install) to install `conda`, and for more info check [our previous blog post on installing Python](https://www.biodsc.nl/posts/installing_conda_python.html) or [this tutorial](https://conmeehan.github.io/PathogenDataCourse/Worksheets/CondaInstallAndUse.html). Then, install BLAST by running:\n\n\n\n::: {.cell filename='bash'}\n\n```{.bash .cell-code}\nconda install -c bioconda blast\n```\n:::\n\n\n\n## Case study: Micro-Tom tomato\n\nWe will turn to tomato for a small case study. The reference genome for tomato was generated from the 'Heinz 1706' variety. Whether this has any connection to the famous ketchup brand is unclear but it would not be too surprising if it did! However, many molecular plant biologists work with a variety called 'Micro-Tom' because of its small size, fast generation time, and its amendability to genetic transformation. Recently, a *de novo* assembled high-quality Micro-Tom genome was published by [Shirasawa & Ariizumi (2024)](https://doi.org/10.5511/plantbiotechnology.24.0522a). In the data availability section of this paper we find that this assembly is indeed not deposited to NCBI, but it's available from other sources including (surprisingly) a [Google Drive folder](https://drive.google.com/drive/folders/1sIxYdA7gNozR3jN_ntGhylcILJmctk-5).\n\nNow for the case study: a colleague was genotyping CRISPR-Cas mutants in Micro-Tom, using the Heinz 1706 genome as a reference. All plants that she genotyped, regardless of whether they carried the intended CRISPR-Cas-induced mutation,\nhad additional mutations in the gene of interest. This gave rise to the following question:\n\n> Are these mutations **CRISPR-Cas off-target mutations** or simply **polymorphisms** present in variety Micro-Tom with respect to Heinz 1706?\n\nTo answer this question, let's create a project folder called `local_blast`, with subfolders `results/`, `data/`, and `data/genomes/`. Then, download the Micro-Tom genome (`SLM_r2.0.pmol.fasta`) from the Google Drive folder into the `data/genomes/` folder. In addition, place a fasta file with the genomic sequence of our gene of interest (in this case: `Solyc02g089160.fasta`) from the reference genome in the `data/` folder. The project should look like this now: \n\n```bash\nlocal_blast\n├── data\n│   ├── genomes\n│   │   ├── SLM_r2.0.pmol.fasta\n│   └── Solyc02g089160.fasta\n└── results  \n```\n\nWe first need to make a BLAST database. This is a data structure that enables BLAST to quickly find similar sequences. In the following command, we specify where the genome is stored, the `dbtype` (in this case `nucl` for nucleotides), and the name of the resulting blast database:\n\n\n\n::: {.cell filename='bash'}\n\n```{.bash .cell-code}\nmakeblastdb -in genomes/SLM_r2.0.pmol.fasta -dbtype nucl -out genomes/S_lyco_MT\n```\n:::\n\n\n\nWe will then see three new files in our `genomes` folder, with the name we indicated (`S_lyco_MT`) and rather obscure file extensions (`.nsq`, `.nin` and `.nhr`):\n\n```bash\nlocal_blast\n├── data\n│   ├── genomes\n│   │   ├── SLM_r2.0.pmol.fasta\n│   │   ├── S_lyco_MT.nsq   <\n│   │   ├── S_lyco_MT.nin   <\n│   │   └── S_lyco_MT.nhr   <\n│   └── Solyc02g089160.fasta\n└── results  \n```\n\nWe're now ready to run BLAST. We specify the query with the `-query` argument, and in this case, it's the fasta file that was stored in the `data` folder before:\n\n\n\n::: {.cell filename='bash'}\n\n```{.bash .cell-code}\nblastn -query data/Solyc02g089160.fasta -db data/genomes/S_lyco_MT\n```\n:::\n\n\n\nThe default output format is a verbose plain-text visual output designed for human readibility, but not ideal for automation by scripting. Nonetheless, it's good for a quick check. Below follows a small portion of the full BLAST output, highlighting a polymorphism betweeen Heinz and Micro-Tom:\n\n\n\n::: {.cell filename='partial output'}\n\n```{.bash .cell-code}\nQuery  241       TCTGTTACTAAATTGAAGTTGTATTATGGTTTATGCAGATGGGAAGAAATAGGTGGAGAT  300\n                 |||||||||||||||||||||||||||||||||||| |||||||||||||||||||||||\nSbjct  67371277  TCTGTTACTAAATTGAAGTTGTATTATGGTTTATGCTGATGGGAAGAAATAGGTGGAGAT  67371336\n                                                     ^\n                                                    SNP    \n```\n:::\n\n\n\nThe Heinz allele (query) contains an `A` base, while the Micro-Tom genome (subject) has a `T` at this position. This is an expected single-nucleotide polymorphism in Micro-Tom, and in fact is one of the three polymorphisms responsible for the dwarf phenotype of Micro-Tom ([Marti et al., 2006](https://academic.oup.com/jxb/article/57/9/2037/622929))!\n\nFor many purposes it would be better to have tabular output. To get this, we add `-outfmt 6` as a parameter to the BLAST call:\n\n\n\n::: {.cell filename='bash'}\n\n```{.bash .cell-code}\nblastn -query Solyc02g089160.fasta -db data/blastdbs/S_lyco_MT -outfmt 6\nS.lycopersicum\tSLM_r2.0ch02\t99.807\t519\t1\t0\t1\t519\t67371037\t67371555\t0.0\t953\n                      ^            ^        ^ \n                  chromosome   %identity mismatches \n```\n:::\n\n\n\nThe columns correspond to the following parameters: `qseqid sseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore`, together refered to as the standard (or `std`) set of parameters. For more info see [this page](https://www.metagenomics.wiki/tools/blast/blastn-output-format-6). You can add get the actual sequence on the Micro-Tom genome (subject) to the output by adding `sseq` to the `std` list of output (you may need to scroll through the code block to see the sequence):\n\n\n\n::: {.cell filename='bash'}\n\n```{.bash .cell-code}\nblastn -query Solyc02g089160.fasta -db data/blastdbs/S_lyco_MT -outfmt \"6 std sseq\"\nS.lycopersicum\tSLM_r2.0ch02\t99.807\t519\t1\t0\t1\t519\t67371037\t67371555\t0.0\t953\tTGCTGAATTTGATTTTTAAATCGGAGTTAACAAATAATTATGGTTCTTATTATAGGATAAGAGCCTGGAACACCAAAACTCATTTTTGGTATTTGGAGGTGGTACTAGACAATGTCCTGGAAAGGAACTTGGTGTAGCAGAAATTTCCACATTTCTTCATTACTTCGTAACAAAATACAGGTATTTAATATATAAACATATATAATAAAAAAATTATTAATTTTATCTCGTATTTGATGATCTGTTACTAAATTGAAGTTGTATTATGGTTTATGCTGATGGGAAGAAATAGGTGGAGATAAACTGATGAAATTCCCAAGAGTTGAAGCACCAAATGGTCTACGGATTAGAGTTTCAGCTCACTAACTATCAATTCATGAATGTACAGAGAAAAAAAAATTCAAAAAAAAAAGAGAAGAGATTTGTAGGATGCAAAGCTAAGAGTAACATGGGATGTACAACTTAATTATTATTCCCGCTAACATAATCACGAATTAAACACAATTTTTTGCAGAGTTA\n```\n:::\n\n\n\nInstead of printing the results to the terminal, you might want to save it in a tab-delimited file:\n\n\n\n::: {.cell filename='bash'}\n\n```{.bash .cell-code}\nblastn -query Solyc02g089160.fasta -db data/blastdbs/S_lyco_MT -outfmt \"6 std sseq\" > results/blast_result_Solyc02g089160_MT.tsv\n```\n:::\n\n\n\n```bash\nlocal_blast\n├── data\n│   ├── genomes\n│   │   ├── SLM_r2.0.pmol.fasta\n│   │   ├── S_lyco_MT.nsq\n│   │   ├── S_lyco_MT.nin\n│   │   └── S_lyco_MT.nhr\n│   └── Solyc02g089160.fasta\n└── results\n    └── blast_result_Solyc02g089160_MT.tsv   <\n```\n\n## Controlling BLAST results\n\nIn this example we get a quite 'clean' BLAST result: there's only one hit, and clearly, this is the genomic sequence that corresponds to the sequence we used as a query. In most real-life scenarios, BLAST results can be much more confusing. For example, here we BLAST a 3000 bp promoter region of a tomato gene to a wild tomato species genome, and get six hits.\n\n\n\n::: {.cell filename='bash'}\n\n```{.bash .cell-code}\nblastn -query tomato_promoter.fasta -db data/blastdbs/S_habro_LA0407_Yu2022  -outfmt \"6 std\" | column -t\ntomato_promoter GWHBJTH00000009  92.685  3021  150  45  2    3000  2505440  2502469  0.0        4289\ntomato_promoter GWHBJTH00000009  83.794  759   66   25  39   757   2505702  2504961  0.0        667\ntomato_promoter GWHBJTH00000009  86.170  470   39   7   26   482   2505139  2504683  2.94e-134  484\ntomato_promoter GWHBJTH00000009  77.184  618   61   30  202  757   2505837  2505238  8.90e-75   287\ntomato_promoter GWHBJTH00000009  81.250  192   21   4   26   204   2504872  2504683  7.33e-31   141\ntomato_promoter GWHBJTH00000009  82.584  178   14   5   583  757   2505702  2505539  7.33e-31   141\n                                          ^              ^    ^\n                                        length        qstart qend \n```\n:::\n\n\nBased on the `length` of the alignment, and the start and end coordinate on the query sequence (`qstart` and `qend`), we can see that only the top hit covers nearly the full 3000 basepairs of the query sequence, the rest of the hits are short. Let's filter out all the hits that cover less than 70% than the query sequence using the `-qcov_hsp_perc 70` argument:\n\n\n\n::: {.cell filename='bash'}\n\n```{.bash .cell-code}\nblastn -query tomato_promoter.fasta -db data/blastdbs/S_habro_LA0407_Yu2022  -outfmt \"6 std\" -qcov_hsp_perc 70 | column -t\ntomato_promoter  GWHBJTH00000009  92.685  3021  150  45  2  3000  2505440  2502469  0.0  4289\n```\n:::\n\n\n\nYep, the short hits are gone. Likewise, it's also possible to filter on the percentage of identity between query and subject using `-perc_identity`.\n\n## Perspectives\n\nIn this blog post, we discussed only one use case of local BLAST searches by searching through a genome assembly. There's much more to discover! For example, you can use BLAST to search proteomes as well. In addition, you can search for more than one query at the same time: see [this lesson](https://dbsloan.github.io/TS2019/exercises/local_blast.html) for an example where all proteins from the bacterium *E. coli* are compared to all proteins of *Salmonella enterica*. Taken together, understanding how to use BLAST locally gives you the power to answer complex comparative genomics questions with just a few commands. Happy BLASTing!\n\n\n## Credits\n\n- ASCII art filetrees were drawn with [tree.nathanfriend.com](tree.nathanfriend.com).",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}