
::: {.callout-note}
## Note
Most questions originate from the carpentry lesson ["Plotting and Programming in Python"](http://swcarpentry.github.io/python-novice-gapminder/)
:::
---


# INSERT THE REGULAR EXERCISES AS WELL!



# Additional exercises Lesson 8


### Epicardial cells
::: {.callout-note appearance="simple"}
## To load the data from the kohela study [Kohela et al.](https://doi.org/10.1126/scitranslmed.abf2750) (GSE149331) we can also download it directly from the <i>bio</i>DSC website, and immediately transpose it in one line:

```Python
# Import kohela data; note the .T at the end, which immediately transposes!
df_cells_kohela2 = \
    pd.read_csv("https://www.biodsc.nl/workshop-materials/py-intro/kohela-et-al.csv",header=0,index_col=0).T
```
:::
::: {.callout-tip icon='false'}
## Question A
In the [RNA-seq data](https://www.biodsc.nl/workshop-materials/py-intro/kohela-et-al.csv), we can create another column that reflects the condition
of the cells, WT or mutant. Fill in the blanks to achieve this:

```python
df_cells_kohela2['Condition'] = ____

df_cells_kohela2.loc[df_cells_kohela2.index.str.contains('WT_'), 'Condition'] = ____
df_cells_kohela2.loc[df_cells_kohela2.index._______, _________] = ______
```
:::

::: {.callout-caution collapse='true' icon='false'}
## Answer

```Python
df_cells_kohela2['Condition'] = 'unknown'
df_cells_kohela2.loc[df_cells_kohela2.index.str.contains('WT_'), 'Condition'] = 'WT'
df_cells_kohela2.loc[df_cells_kohela2.index.str.contains('mutant_'), 'Condition'] = 'mutant'
```

You can inspect the values in the new column to check if the contents are as expected:
```
df_cells_kohela2['Condition']
```

:::

::: {.callout-tip icon='false'}
## Question B
What is the difference between str.contains and str.match?
:::
::: {.callout-caution collapse='true' icon='false'}
## Answer
See documentation for [str.contains](https://pandas.pydata.org/docs/reference/api/pandas.Series.str.contains.html) and [str.match](https://pandas.pydata.org/docs/reference/api/pandas.Series.str.match.html).
`str.contains` tests whether the search string is contained in each string (at any location), whilst `str.match` determines if each string starts with a match.
:::


::: {.callout-tip icon='false'}
## Question C

Now calculate the mean value of TFAP2A expression in WT cells vs. mutant cells. 
Does there appear to be more TFAP2A expression in the mutant cells?
:::
::: {.callout-caution collapse='true' icon='false'}
## Answer
```
df_cells_kohela2.loc[:,['TFAP2A','Condition']].groupby('Condition').mean()
```
Yields
```
             TFAP2A
Condition          
WT         1.535655
mutant     9.601550
```
so this indeed appears to be the case.
:::

### Gene expression

::: {.callout-tip icon='false'}
## Question D ... DOUBLE CHECK THIS ... WHY SEPARATE CRP & ACTA1??? 
- Convert the data below to a file you can import (e.g.: csv, tsv), import it to a pandas df, and determine the following:
    1. The average CRP gene expression per condion.
    2. The corresponding standard deviations.
    3. The log2-fold change between WT, condition A, and condition B.
    4. Do the same for ACTA1.
    5. Normalize all gene expression levels to their average respective wild type levels.

```
gene	expression	condition
CRP	873	WT
CRP	324	WT
CRP	214	WT
CRP	151	WT
CRP	1220	A
CRP	450	A
CRP	300	A
CRP	210	A
CRP	800	B
CRP	200	B
CRP	200	B
CRP	130	B
ACTA1	7457	WT
ACTA1	2342	WT
ACTA1	8000	WT
ACTA1	9000	WT
ACTA1	6500	A
ACTA1	2200	A
ACTA1	7500	A
ACTA1	8000	A
ACTA1	1000	B
ACTA1	1123	B
ACTA1	3211	B
ACTA1	1231	B
```

:::


::: {.callout-caution collapse='true' icon='false'}
## Answer
We saved the data as tab-separated-value (tsv) [file](data/gene_expression.tsv) and load it into a dataframe using the read_csv command but now specify the tab character (**\\t**) as the value separator:

```Python
df = pd.read_csv('gene_expression.tsv',header=0, sep='\t')
# or alternatively:
# pd.read_table('gene_expression.tsv')
```

1. The average CRP gene expression per condion.    
```Python
df[df.gene=='CRP'].groupby(['gene','condition'])['expression'].mean()
```

2. The corresponding standard deviations.
```Python
df.groupby(['gene','condition'])['expression'].std()
```

3. The log2-fold change between WT, condition A, and condition B.
4. Do the same for ACTA1.
```Python
dfmean = df.groupby(['gene','condition'])['expression'].mean().to_frame()
WT = dfmean.index.get_level_values(1)=='WT'
ratios = dfmean.loc[~WT].reset_index(level=1,drop=True)/dfmean.loc[WT].reset_index(level=1,drop=True)
ratios.index=dfmean[~WT].index
print(np.log2(ratios))
```

5. Normalize all gene expression levels to their average respective wild type levels.
```Python
dfw = df.copy()
CRP = dfw.gene=='CRP'
dfw.loc[ CRP,'expression']  = dfw.loc[CRP,'expression']/dfmean.loc[('CRP','WT')].values
dfw.loc[~CRP,'expression'] = dfw.loc[~CRP,'expression']/dfmean.loc[('ACTA1','WT')].values
```
:::



### GDPs
::: {.callout-tip icon='false'}
## Question E

1. Between '87 and '92 the GDP of most countries took a hit. Are there any countries which had a positive increase between those two years? Which ones?
2. Calculate the average GDP between all European countries per year.
3. Normalize the dataframe by this trend.
:::


::: {.callout-caution collapse='true' icon='false'}
## Answer
:::


### Exploring available methods using the dir() function

Python includes a dir() function that can be used to display all of the available methods (functions) that are built into a data object. In Episode 4, we used some methods with a string. But we can see many more are available by using dir():

```python
my_string = 'Hello world!'   # creation of a string object 
dir(my_string)
```

This command returns:

```python
['__add__',
...
'__subclasshook__',
'capitalize',
'casefold',
'center',
...
'upper',
'zfill']
```

You can use help() or Shift+Tab to get more information about what these methods do.

::: {.callout-tip icon='false'}
## Question E
Assume Pandas has been imported and the Gapminder GDP data for Europe has been loaded as data. Then, use dir() to find the function that prints out the median per-capita GDP across all European countries for each year that information is available.
:::

::: {.callout-caution collapse='true' icon='false'}
## Answer
Among many choices, dir() lists the median() function as a possibility. Thus,
```Python
data.median()
```
:::

### Interpretation
::: {.callout-tip icon='false'}
## Question F
Polandâ€™s borders have been stable since 1945, but changed several times in the years before then. How would you handle this if you were creating a table of GDP per capita for Poland for the entire twentieth century?
:::

::: {.callout-caution collapse='true' icon='false'}
## Answer
???
:::
